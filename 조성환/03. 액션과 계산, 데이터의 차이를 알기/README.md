# 액션과 계산, 데이터의 차이를 알기

## 이번장에서 살펴볼 내용

- 액션과 계산 데이터가 어떻게 다른지 베우기
- 문제에 대해 생각하거나 코드를 작성할 때 또는 코드를 읽을 때 액션과 계산, 데이터를 구분해서 적용해보기
- 액션이 코드 전체로 퍼질 수 있다는것을 이해하기
- 이미 있는 코드에서 어떤 부분이 액션인지 찾아보기

## 액션과 계산, 데이터

함수형 프로그래머는 액션과 계산, 데이터를 구분하는것이 중요하기 때문에 다시 한번 요약

| 액션 | 계산 | 데이터 |
| --- | --- | --- |
| 실행 시점과 횟수에 의존한다 | 입력으로 출력을 계산한다 | 이벤트에 대한 사실 |
| 부수효과가 있는 순수하지 않은 함수 | 순수함수 |  |
| 이메일 보내기, 데이터베이스 읽기 | 최댓값 찾기, 이메일 주소 올바른지 확인하기 | 사용자가 입력한 주소, 은행 API로 읽은 달러 수량 |

### 문제에 대해 생각할 때

코딩 시작 전에 문제에 대해서 고민하고 있을 때도 문제를 액션과 계산, 데이터로 나눠 생각해볼 수 있음

- 특별히 주의해야 할 부분인 `액션`
- 결정을 내려야 하는 부분인 `계산`
- `데이터`로 처리해야 할 부분

### 코딩할 때

최대한 **액션에서 계산을 빼내려** 하고, **계산에서 데이터를 분리**할 수 있는지 생각한다.

### 코드를 읽을 때

엑션과 계산, 데이터 중에 **어디에 속하는지 잘 살펴 보면서 읽어야** 된다.   
**숨어있는 액션을 찾고**, 시간의 의존하는 **액션을 조심해**야 된다.

> [!NOTE]
> 코드 작성 전,중,후에 액션과 계산, 데이터를 나누려고 끊임없이 고민해야 됨

## 액션을 장보기 과정에 대입해보기

### 장보기 과정을 간단하게 나열하면
1. 냉장고 확인
2. 상점으로 이동
3. 필요한것 구입
4. 집으로 이동

이렇게 되는데 이것은 모두 실행횟수와 시점에 의존하기 때문에 액션

### 액션에서 계산, 데이터 추출

각 액션에서 코드를 분리 해보면

1. 냉장고 확인
    - 냉장고 확인은 `액션`
    - 냉장고 확인 후에 나온 현재 재고는 `데이터`

2. 상점으로 이동
    - 이동하는건 `액션`
    - 경로는 `데이터`

3. 필요한것 구입
    - 구매 하는것은 `액션`
    - 요리에 필요한 재료는 `데이터`
    - 필요한 재료에서 현재 재고를 빼고 나머지로 구매목록을 결정하는건 `계산`
    - 구매목록은 `데이터`

4. 집으로 이동
    - 이동하는건 `액션`
    - 경로는 `데이터`

이렇게 나누다 보면 액션과 계산, 데이터를 더 많이 찾을 수 있고 풍부한 모델을 만들수 있음   
ex) 냉장실 확인, 냉동실 확인, 장바구니 담기, 계산하기   
   
> [!NOTE]
> 계속 나누다 보면 점점 더 복잡해진다고 생각할 수 있지만, 액션에 숨어있는 다른 액션이나 계산 또는 데이터를 발견하기 위해 나눌수 있는 만큼 나누는것이 좋음   

**장보기 과정에서 배울수 있는 것들**   
- 액션과 계산, 데이터는 어디에서 적용할 수 있음
- 액션안에는 계산과 데이터, 다른 액션이 숨이 있을수 있음   
    함수형 프로그래밍에서는 액션을 더 작은 액션과 계산, 데이터로 나누고 나누는 것을 언제 멈춰야 할지 아는 것이 중요
- 계산은 더 작은 계산과 데이터로 나누고 연결할 수 있음
- 데이터는 데이터만 조합할 수 있음
- 계산은 때로 우리 머리속에서 일어남   
    계산은 우리 머리속 사고 과정에 녹아있다는것을 인식하고 계산을 찾으려 노력하면 더 쉽게 찾을수 있음

> ❓
> "나눌수 있는 만큼 나누는것이 좋다"와 "언제 나누는 것을 멈춰야 할지 아는것이 중요"하다는 내용이 좀 기준잡기가 애매한 것 같음

## 새로 만드는 코드에 함수형 사고 적용하기

쿠폰독은 쿠폰에 관심있는 구독자들에게 이메일로 쿠폰을 매주 보내주는 서비스로 사용자를 더 늘리기 위해 친구 10명을 추천하면 더 좋은 쿠폰을 보내주려고 한다.

### 생각해보기

간단해 보이지만, 코드를 작성하기 위해 어떤 것을 알아야 하고 무엇을 결정해야 하고 또 어떤것을 해야 할지 생각해보기   
순서도 중요하지 않고, 구체적으로 작성할 필요도 없음   

- 이메일 보내기
- 데이터 베이스에서 구독자 가져오기
- 쿠폰에 등급 매기기
- 데이터 베이스에서 쿠폰 읽기
- 이메일 제목
- 이메일 주소
- 추천 수
- 어떤 이메일이 쿠폰을 받을지 결정하기
- 구독자 DB 레코드
- 쿠폰 DB 레코드
- 쿠폰 목록 DB 레코드
- 구독자 목록 DB 레코드
- 이메일 본문

이렇게 해야 할 것들을 나열하는 과정을 먼저 해보기

### 액션과 계산, 데이터로 나누어보기

위에서 생각해본 내용을 액션과 계산, 데이터로 나눠보기

- 이메일 보내기 `A`
- 데이터 베이스에서 구독자 가져오기 `A`
- 쿠폰에 등급 매기기 `D`
- 데이터 베이스에서 쿠폰 읽기 `A`
- 이메일 제목 `D`
- 이메일 주소 `D`
- 추천 수 `D`
- 어떤 이메일이 쿠폰을 받을지 결정하기 `C`
- 구독자 DB 레코드 `D`
- 쿠폰 DB 레코드 `D`
- 쿠폰 목록 DB 레코드 `D`
- 구독자 목록 DB 레코드 `D`
- 이메일 본문 `D`

쿠폰에 등급 매기기는 계산이라고 생각하지만, 데이터베이스 테이블에 이미 등급이 있다는 가정으로 데이터라고 표시 한거라고 생각
등급 매기기가 아니라 `등급있는 쿠폰 데이터` 가 아닐까 싶음

### 과정 그려보기

위에서 고민해봤던 내용을 토대로 액션, 계산, 데이터를 나누어 과정을 그려보기

**먼저 선행되야 하는 것이 없는 것들부터 작성**

| 액션 | 계산 | 데이터 |
| --- | --- | --- |
| DB에서 구독자 가져오기 |  | 구독자 목록 |
| DB에서 쿠폰 목록 가져오기 |  | 쿠폰 목록 |

**그 다음에 할수 있는 목록 작성**   
구독자 목록으로 쿠폰 등급을 만든다거나,   
쿠폰 목록으로 good 쿠폰 목록, best 쿠폰 목록을 만드는것

| 액션 | 계산 | 데이터 |
| --- | --- | --- |
| {...} | {...} | {...} |
|  |  | 구독자 목록 |
|  | 쿠폰 등급 결정하기 | 쿠폰 등급 |
|  |  | 쿠폰 목록 |
|  | good 쿠폰 선택하기 | good 쿠폰 목록 |
|  | best 쿠폰 선택하기 | best 쿠폰 목록 |


**다음 할수 있는 목록**
구독자 목록, 등급, 만든 쿠폰 목록으로 보낼 이메일 데이터를 만드는 과정

| 액션 | 계산 | 데이터 |
| --- | --- | --- |
| {...} | {...} | {...} |
|  |  | 구독자 목록 |
|  |  | 쿠폰 등급 |
|  |  | good 쿠폰 목록 |
|  |  | best 쿠폰 목록 |
|  | 쿠폰등급에 따른 이메일 만들기 | 이메일 |

**그 다음 할 수 있는 목록**
만들어진 이메일을 가지고 보내는 액션

| 액션 | 계산 | 데이터 |
| --- | --- | --- |
| {...} | {...} | {...} |
|  |  | 이메일 |
| 이메일 보내기 |  |  |

**최종**

| 액션 | 계산 | 데이터 |
| --- | --- | --- |
| DB에서 구독자 가져오기 |  | 구독자 목록 |
|  | 쿠폰 등급 결정하기 | 쿠폰 등급 |
| DB에서 쿠폰 목록 가져오기 |  | 쿠폰 목록 |
|  | good 쿠폰 선택하기 | good 쿠폰 목록 |
|  | best 쿠폰 선택하기 | best 쿠폰 목록 |
|  | 쿠폰등급에 따른 이메일 만들기 | 이메일 |
| 이메일 보내기 |  |  |

> [!TIP]
> 과정을 그려보는 것이 액션과 계산, 데이터를 발견하는것에 많은 도움을 주는것 같음   

### 코드로 구현하기

**구독자(데이터)**
```js
const 구독자 = {
    email: "cho@gmail.com",
    rec_count: 15
}
```

**쿠폰 등급 결정하기(계산)**
```js
const 쿠폰_등급_결정하기 = (구독자) => {
    if(구독자.rec_count >= 10){
        return "best";
    } else {
        return "good";
    }
}
```

**쿠폰(데이터)**
```js
const 쿠폰 = {
    code: "New",
    rank: "best"
}
```

**쿠폰 선택하기(계산)**
```js
const 쿠폰_선택하기 = (쿠폰목록, 랭크) => {
    return 쿠폰목록.filter((쿠폰) => 쿠폰.rank === 랭크)
}
```

**이메일(데이터)**
```js
const 이메일 = {
    from: "seong@gmail.com",
    to: "cho@gmail.com",
    subject: "title",
    body: "content"
}
```

**이메일 만들기(계산)**   
```js
const 구독자_이메일_만들기 = (구독자, 굿쿠폰목록, 베스트쿠폰목록) => {
    const rank = 쿠폰_등급_결정하기(구독자);
    if(rank === "best"){
        return {
            from: "company@gmail.com",
            to: 구독자.email,
            subject: "베스트 쿠폰",
            body: "베스트 쿠폰: " + 베스트쿠폰목록.join(", ")
        }
    } else {
        return {
            from: "company@gmail.com",
            to: 구독자.email,
            subject: "굿 쿠폰",
            body: "굿 쿠폰: " + 굿쿠폰목록.join(", ")
        }
    }
}

const 이메일_목록_만들기 = (구독자목록, 굿쿠폰목록, 베스트쿠폰목록) => {
    return 구독자목록.map((구독자) => 구독자_이메일_만들기(구독자, 굿쿠폰목록, 베스트쿠폰목록));
}
```

**이메일보내기(액션)**
```js
const 이메일_보내기 = () => {
    const 쿠폰목록 = fetchCouponsFromDB();
    const 굿쿠폰목록 = 쿠폰_선택하기(쿠폰목록, "good");
    const 베스트쿠폰목록 = 쿠폰_선택하기(쿠폰목록, "best");
    const 구독자목록 = fetchSubscriversFromDB();
    const 이메일목록 = 이메일_목록_만들기(구독자목록, 굿쿠폰목록, 베스트쿠폰목록);
    이메일목록.forEach((이메일) => emailSystem.send(이메일))
}
```

- 데이터를 파악하는 것으로 시작해서 계싼과 추가 데이터를 도출
- 액션으로 모든것을 묶음
- 데이터를 사용하는데 제약이 많고, 액션은 가장 제약이 없음
- 데이터를 먼저 구현하고 계산을 구현한 후에 마지막으로 액션을 구현하는 것이 함수형 프로그래밍의 일반적인 구현 순서

> [!NOTE]
> 데이터 -> 계산 -> 액션으로 구현하는것이 함수형 프로그래밍의 일반적인 구현 순서      

## 이미 있는 코드에 함수형 사고 적용하기

### 코드 예시

**예시상황**   
자회사에 수수료를 보내기 위해 만든 코드로 sendPayout 함수는 실제 은행 계좌로 송금하는 액션

```js
const figurePayout = (affiliate) => {
    const owed = affiliate.sales * affiliate.commission;
    if(owed > 100) {
        sendPayout(affiliate.bank_code, owed);
    }
}

const affiliatePayout = (affiliates) => {
    affiliates.forEach((affiliate) => figurePayout(affiliate));
}

const main = (affiliates) => {
    affiliatePayout(affiliates);
}
```

액션은 호출하는 시점과 횟수에 의존하게 되기 때문에 **액션을 포함한 함수도 액션**이 됨   
그래서 코드 전체로 액션이 퍼져 나가서 전체 코드가 액션이 됨

### 액션은 다양한 형태로 나타남
- 함수 호출 `alert("something")`
- 메서드 호출 `console.log("something")`
- 생성자 `new Date()`
- 표현식 `user.first_name`
- 상태 `delete user.first_name`



## 액션, 계산, 데이터 요약

### 데이터

- 이벤트에 대한 사실   
- 의미를 부여하려면 구조로 부여가 가능, 순서가 중요하면 순서를 보장하는 데이터 구조를 사용
- 불변성을 지키기 위해 두가지 원칙을 사용하는데, `카피-온-라이트`와 `방어적 복사`의 원칙을 사용
- 장점은 `직렬화`, `동일성 비교`, `자유로운 해석`의 장점이 있음
- 단점은 꼭 해석이 필요하다는 점

### 계산
- 입력값으로 출력값을 만듬
- 함수로 구현
- 계산에는 연산을 이용해서 입력값에서 출력값으로 만드는 것을 표현
- 계산이 좋은 이유
    - 테스트하기 쉬움
    - 기계적인 분석이 쉬움(코드를 실행하지 않고 분석하는 정적 분석)
    - 조합하기 좋음(일급 계산)
- 계산을 사용하면서 걱정하지 않아도 되는것
    - 동시에 실행되는 것
    - 과거에 실행되었던 것이나 미래에 실핼할 것
    - 실행 횟수
- 계산의 단점은 실행하기 전에 어떤 일이 발생할지 알 수 없다는 점
- 계싼은 순수함수, 수학함수라고 부름

### 액션
- 외부 세계에 영향을 주거나 받는것
- 실행 시점과 횟수에 의존
- 함수로 구현
- 외부 세상에 영향을 주는것으로 의미를 가짐
- 이메일 보내기, 계좌에서 인출하기
- 순수하지 않은 함수, 부수 효과 함수
- 다루기 힘듬
- 우리가 소프트웨어를 실행 하려는 가장 중요한 이유
- 액션을 잘 사용하기 위한 방법
    - 가능한 액션을 적게 사용
    - 가능한 작게 만듬
    - 내부에 계산과 데이터만 있고 가장 바깥쪽에 액션이 있는 구조가 이상적
    - 호출 시점에 의존하는 것을 제한

---

## 연습

이걸 앞에서 배운걸로 개선

```js
const figurePayout = (affiliate) => {
    const owed = affiliate.sales * affiliate.commission;
    if(owed > 100) {
        sendPayout(affiliate.bank_code, owed);
    }
}

const affiliatePayout = (affiliates) => {
    affiliates.forEach((affiliate) => figurePayout(affiliate));
}

const main = (affiliates) => {
    affiliatePayout(affiliates);
}
```

### 생각해보기
- 제휴사 목록 가져오기
- 제휴사 목록
- 수수료 결정하기
- 수수료
- 수수료 보낼 목록 결정하기
- 수수료 보낼 목록
- 수수료 보내기

### 액션, 계산, 데이터로 나눠보기

- 제휴사 목록 가져오기 `액션`
- 제휴사 목록 `데이터`
- 수수료 결정하기 `계산`
- 수수료 `데이터`
- 수수료 보낼 목록 결정하기 `계산`
- 수수료 보낼 목록 `데이터`
- 수수료 보내기 `액션`

### 과정 그려보기

| 액션 | 계산 | 데이터 |
| --- | --- | --- |
| DB에서 제휴사 가져오기 |  | 제휴사 목록 |
|  | 수수료 결정하기 | 수수료 |
|  | 수수료 보낼 목록 결정하기 | 수수료 보낼 목록 |
| 수수료 보내기 |  |  |

### 코드로 구현

**제휴사(데이터)**
```js
const 제휴사 = {
    bank_code = 12,
    sales = 1010,
    commission = 0.1,
}
```

**수수료 결정하기(계산)**
```js
const 수수료_결정하기 = (sales, commission) => {
    return sales * commission
}
```

**수수료(데이터)** 
```js
const 수수료 = 105
```

**수수료 보낼 목록 결정하기(계산)**
```js
const 수수료_보낼_목록 결정하기 = (제휴사목록) => {
    return 제휴사목록.filter((제휴사) => {
       const 수수료 = 수수료_결정하기(제휴사.sales, 제휴사.commission);
       return 수수료 > 100;
    })
}
```

**수수료 보내기(액션)**
```js
const 수수료_보내기 = () => {
    const 제휴사목록 = fetchAffiliatesFromDB();
    const 수수료보낼제휴사목록 = 수수료_보낼_목록_결정하기(제휴사목록);
    수수료보낼제휴사목록.forEach((제휴사) => {
        sendPayout(제휴사.bank_code, 수수료_결정하기(제휴사.sales, 제휴사.commission))
    })
}

// or

const 수수료_저장하기 = (수수료보낼제휴사목록) => {
    const 수수료저장된목록 = 수수료보낼제휴사목록.map((제휴사) => {
        const 수수료 = 수수료_결정하기(제휴사.sales, 제휴사.commission);
        return {...제슈사, sendCommission: 수수료};
    })
    return 수수료저장된목록;
}

const 수수료_보내기 = () => {
    const 제휴사목록 = fetchAffiliatesFromDB();
    const 수수료보낼제휴사목록 = 수수료_보낼_목록_결정하기(제휴사목록);
    const 수수료저장된목록 = 수수료_저장하기(수수료보낼제휴사목록);
    수수료저장된목록.forEach((제휴사) => {
        sendPayout(제휴사.bank_code, 제휴사.sendCommission);
    })
}

// or 

const 수수료_보내기 = () => {
    const 제휴사목록 = fetchAffiliatesFromDB();
    제휴사목록.forEach((제휴사) => {
        const 수수료 = 수수료_결정하기(제휴사.sales, 제휴사.commission);
        if(수수료 > 100) {
            sendPayout(제휴사.bank_code, 수수료);
        }
    })
}

```
> ❓ 질문
> 수수료 구하는 함수가 두번 실행되는것, 수수료를 저장하는 계산을 하나 더 만드는것, 계산을 빼고 그냥 액션에서 계산을 하는 것이 있는데 액션과 계산은 테스트를 위해 나눌수록 좋으니까 세번째꺼는 안좋은 방법일것 같은데, 어떤게 좋은 방법인지 모르겠습니다. 좋다고 생각하시는 방법이나, 새로운 방법이 있으신가요?!