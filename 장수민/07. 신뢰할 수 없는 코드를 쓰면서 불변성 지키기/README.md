## 7장 - 신뢰할 수 없는 코드를 쓰면서 불변성 지키기

`카피-온-라이트`를 적용할 수 없는 코드를 함께 사용해야 할 때가 있다. 바꿀 수 없는 라이브러리나 레거시 코드가 데이터를 변경하는 경우가 그렇다.

**이번 장에서는 데이터를 변경하는 코드를 어쩔 수 없이 함께 사용하면서 불변성을 지키는 방법에 대해 배워보자.**

### 레거시 코드와 불변성

>[!NOTE]
> MegaMart는 블랙 프라이뎅 세일을 준비하기로 했고 당장 시간이 없어서 `black_friday_promotion(shopping_cart)`를 추가해야 하는 상황이다.

카피-온-라이트 원칙을 지킬 수 없고, `black_friday_promotion(shopping_cart)`를 바꿀 수도 없다면 **방어적 복사(defensive copy) 원칙**을 사용해볼 수 있다.

### 카피-온-라이트 코드는 신뢰할 수 없는 코드와 상호작용해야 한다

우리가 지금까지 작성한 코드는 불변성이 지켜지는 **안전지대**에 있었다.

>[!WARNING]
> 블랙 프라이데이 행사 함수는 안전지대 밖에 있지만, 결국 요구 사항을 충족하기 위해서 안전하지 않은 함수를 써야 한다. 🚨문제는 안전지대 밖으로 나가거나 신뢰할 수 없는 코드에서 안전지대로 들어오는 데이터는 잠재적으로 바뀐다는 것이다.🚨

### 방어적 복사는 원본이 바뀌는 것을 막아준다

신뢰할 수 없는 코드와 데이터를 주고받는 문제를 푸는 방법은 **복사본을 만드는 것**이다.

#### 들어올 때 데이터를 보호하는 방법

1. 신뢰할 수 없는 코드에 있는 데이터
2. 데이터가 안전지대로 들어온다.
3. 깊은 복사를 한다.(신뢰할 수 없는 코드로 인해 변경되는 데이터가 안전지대 내에 있는 데이터에 영향을 미치지 않는다.)

#### 안전지대에서 나가는 데이터를 보호하는 방법

1. 안전지대에 있는 데이터
2. 깊은 복사를 한다.
3. 깊은 복사를 한 데이터를 안전지대에서 내보낸다.(데이터가 바뀌어도 복사본이기 때문에 영향을 받지 않는다.)

### 방어적 복사 구현하기

원래 코드에서는 `shopping_cart`가 신뢰할 수 없는 코드 `black_friday_promotion`에 의해 바뀔 가능성이 있다.
```ts
function add_item_to_cart(name, price) {
    // 생략
    black_friday_promotion(shopping_cart);
}
```

데이터를 전달하기전에 복사함으로써 `black_friday_promotion`에 의해 `shopping_cart`가 바뀔 가능성을 제거했다.
```ts
function add_item_to_cart(name, price) {
    // 생략
    const cart_copy = deepCopy(shopping_cart);
    black_friday_promotion(cart_copy);
}
```

이제 `black_friday_promotion` 함수가 바꾼 `cart_copy`의 값을 받아야 한다.

>[!WARNING]
> 만약 `shopping_cart = cart_copy;`를 하면 참조 값을 저장하게 되므로 안된다. 방어적 복사를 수행해서 black_friday_promotion에 의해 바뀔 가능성이 농후한 cart_copy가 shopping_cart에 영향을 끼치지 않도록 해야 한다.

데이터를 전달하기 전후에 복사
```ts
function add_item_to_cart(name, price) {
    // 생략
    const cart_copy = deepCopy(shopping_cart);
    black_friday_promotion(cart_copy);
    shopping_cart = deepCopy(cart_copy);
}
```

### 방어적 복사 규칙

1. 데이터가 안전한 코드에서 나갈 때 복사하기
   - 방금 전 예시로, `add_item_to_cart` 함수의 몸체가 안전지대였고 `black_friday_promotion`이라는 신뢰할 수 없는 코드 영역으로 나가게 되므로 깊은 복사를 수행한다.
2. 안전한 코드로 데이터가 들어올 때 복사하기
   - `black_friday_promotion` 함수 실행을 종료하고 안전지대로 돌아오면서 깊은 복사를 수행하고 안전지대에서 사용한다.

### 연습 문제 - MegaMart 급여 계산을 위해 외부 라이브러리를 사용할 때 방어적 복사하기

카피-온-라이트 원칙이 적용되지 않은 payrollCalc()를 감싸서 `payrollCalcSafe`를 만들자.

```ts
function payrollCalc(employees) {
    // 생략
    return payrollChecks;
}

function payrollCalcSafe(employees) {
    const copy_employees = deepCopy(employees);
    const payrollChecks = payrollCalc(copy_employees);
    return deepCopy(payrollChecks);
}
```

>[!TIPS]
> 안전지대로 나가는 데이터가 없다면 복사할 필요가 없다.

### 생각보다 익숙한 방어적 복사

예시
1. 웹 기반 API - 클라이언트는 데이터를 인터넷을 통해 API로 보내려고 직렬화하는 과정에서 깊은 복사본을 만든다. **서로 다른 코드와 원칙을 가진 서비스들이 문제없이 통신할 수 있게 해준다.**
2. 얼랭과 엘릭서(모두 함수형 프로그래밍 언어)는 방어적 복사를 구현

### 쉬는 시간(가벼운 질문)

**Q.** 카피-온-라이트와 방어적 복사는 다른가요?
- 모두 불변성을 유지하기 위해 사용하지만, 방어적 복사는 카피-온-라이트와 다르게 깊은 복사를 한다. 🚨위에서 아래로 모든 계층의 중첩된 데이터를 복사하기 때문에 더 많은 비용을 지불해야하므로 안전지대라면 카피-온-라이트, 신뢰할 수 없는 코드에 데이터를 주고받을 때는 방어적 복사를 사용해야 한다.🚨

### 얕은 복사보다 비싼 깊은 복사

깊은 복사는 원본과 어떤 데이터 구조도 공유하지 않는 것이 얕은 복사와의 차이이다.

잠시 저번 시간을 리마인드하자면,
```ts
// 카피-온-라이트 버전 
function setPriceByName(cart, name, price) {
    // map 메서드는 새로운 배열을 반환하므로 얕은 복사가 적용되어 있다.
    return cart.map((item) => {
       if (item.name === name) {
           return setPrice(item, price);
       } else {
           return item;
       }
    });
}

// setPriceByName을 통해 티셔츠 가격 바꾸기
shopping_cart = setPriceByName(shopping_cart, "t-shirt", 13);
```

처음에 cart 안에 3개의 아이템(티셔츠, 신발, 양말)이 있다고 가정하면 cart 배열과 3개의 아이템 객체, 총 4개가 복사되는 것이 아니다!

**🚨나머지 두 객체인 신발과 양말에 대해서는 변경과 복사가 이뤄지지 않았기 때문에 구조적 공유가 발생해서 총 2개(cart 배열, 티셔츠 객체)만 복사했다.🚨**

하지만 깊은 복사는, 총 4개를 모두 복사한다.

### 자바스크립트에서 구현하기 어려운 깊은 복사

자바스크립트에서는 표준 라이브러리가 좋지 않아 만들기가 어렵다.😅

그래서 Lodash 라이브러리에 있는 깊은 복사 함수를 쓰기를 책에서 추천하고 있다. - `.cloneDeep()`

### 연습 문제 - 불변성을 유지할 수 있는 행동에 관한 문장을 찾고 그 이유 쓰기

1. 레거시 코드와 데이터를 주고받을 때 방어적 복사를 쓴다.
   - 맞다! 모든 중첩된 데이터를 복사하는 비용을 감안하고도 복사본을 만들어서 안전지대를 보호할 수 있다.
2. 레거시 코드와 데이터를 주고받을 때 카피-온-라이트 원칙을 쓴다.
   - 아니다. 레거시 코드가 카피-온-라이트 원칙을 준수하고 있는지 확신할 수 없다.
3. 데이터를 바꾸는 부분이 있는지 확인하기 위해 레거시 코드를 읽고, 데이터를 바꾸는 부분이 없다면 특별한 원칙을 쓰지 않는다.
   - 맞을 수도 있다. 레거시 코드를 분석할 만한 여력이 있다면 인자로 전달한 데이터가 변경되는지 알 수 있다.
4. 방어적 복사를 쓰지 않고 레거시 코드를 카피-온-라이트 방식으로 고친다.
   - 맞다! 하지만, **(내 의견은) 시간에 쫓겨 코드를 작성해야 하는 입장이라면 방어적 복사가 더욱 효율적이라고 생각하고 모듈화가 되어 있거나 내가 직접 건드려볼 수 없는 패키지라면 카피-온-라이트 적용이 불가능할 수도 있다.**
5. 팀에 있는 코드이기 때문에 안전지대에 있다고 생각한다.
   - 아니다...

### 요점 정리

- 방어적 복사는 불변성을 구현하는 원칙이다.
- 방어적 복사는 깊은 복사를 하므로 카피-온-라이트보다 비용이 더 든다.
- 카피-온-라이트와 다르게 방어적 복사는 불변성 원칙을 구현하지 않은 코드로부터 데이터를 보호한다.
- 방어적 복사는 신뢰할 수 없는 코드와 함께 사용할 때만 사용한다.
- 깊은 복사는 중첩된 데이터 전체를 복사하고 얕은 복사는 필요한 부분만 최소한으로 복사한다.

### 느낀 점

```ts
let object = {
    name: 't-shirt',
    price: 7,
};

(function changeObject(obj) {
    obj.price = 13;
})(object);

console.log(object.price); // 13
```
- 자바스크립트의 참조형이라는 개념을 몰랐을 때 changeObject가 반환하는 값도 없는데 price 속성값이 13으로 변경되었다는 사실이 이상하게 느껴졌을 때가 기억난다.
- 위 코드는 너무 쉽고 간단한 예제이지만, 코드 수가 방대해지고 복잡해지면 의도치 않게 데이터의 불변성을 잃기 쉽다고 생각하고 방어적 복사가 중요하다고 느낀다.