## 계층형 설계 II

**이전 장에서 호출 그래프를 그리는 방법과 코드를 잘 구조화하기 위한 계층을 찾아봤다. 이번 장에서는 나머지 세 개 패턴을 보자.**

> [!NOTE]
>
> - 코드를 모듈화하기 위해 추상화 벽을 만드는 법 배우기
> - 좋은 인터페이스가 어떤 것이고 어떻게 찾는지 알아보기
> - 설계가 이만하면 되었다는 시점 찾기
> - 왜 계층형 설계가 유지보수와 테스트, 재사용에 도움이 되는지 이해하기

---

### 패턴 2: 추상화 벽

추상화 벽은 여러 가지 문제를 해결할 수 있는데, ❓팀 간 책임을 명확하게 나눌 수 있다.❓

#### 추상화 벽으로 구현 감추기

추상화 벽(abstraction barrier)은 세부 구현을 감춘 함수로 이루어진 계층이다. 구현을 전혀 몰라도 함수를 쓸 수 있다.

마케팅 팀은 만들어진 함수를 가져다 쓰고, 개발 팀은 함수를 구현한다고 하면 다음과 같은 효과가 생긴다.

1. 추상화 벽 위로 있는 함수를 가져다 쓰기만 하면 된다.
2. 추상화 벽 아래서 일하는 사람은 벽에 있는 함수를 어떻게 쓰는지 신경 쓰지 않고 일할 수 있다.

> [!NOTE] > **추상화 벽은 흔하게 사용하는 라이브러리나 API와 비슷하다.**
>
> - 기상 데이터 API를 만드는 팀이 어떻게 구현을 했는지 신경쓰지 않고 가져다 쓰기만 하면 된다.
> - 책임을 명확하게 나눠준다!

#### 개발팀의 장바구니 데이터 구조 바꾸기

배열을 순서대로 검색하는 것은 성능이 떨어지므로, 해시 맵(자바스크립트에서 객체)을 써서 항목을 추가하거나 삭제, 조회하는 동작을 빠르게 하려고 한다.

데이터 구조를 알고 있는 함수와 아닌 함수로 나눠서 알고 있는 함수의 데이터 구조를 바꾸면 된다.

```tsx
function add_item(cart, item) {
  // return add_element_last(cart, item);
  return objectSet(cart, item.name, item);
}

function calc_total(cart) {
  let total = 0;
  const names = Object.keys(cart);
  for (let i = 0; i < names.length; i++) {
    const item = cart[names[i]];
    total += item.price;
  }
  return total;
}

function setPriceByName(cart, name, price) {
  if (isInCart(cart, name)) {
    const item = cart[name];
    const copy = setPrice(item, price);
    return objectSet(cart, name, copy);
  } else {
    const item = make_item(name, price);
    return objectSet(cart, name, item);
  }
}

function remove_item_by_name(cart, name) {
  return objectDelete(cart, name);
}

function isInCart(cart, name) {
  // return indexOfItem(cart, name) !== null;
  return cart.hasOwnProperty(name);
}
```

중요한 점은, 개발 팀이 위처럼 데이터 구조를 배열에서 객체로 변경했다 하더라도 마케팅 팀은 이전과 동일하게 추상화 벽 위에 함수만 가져다 쓴다는 것이다!

#### 추상화 벽은 언제 사용하면 좋을까?

1. 쉽게 구현을 바꾸기 위해

구현에 대한 확신이 없는 경우 추상화 벽을 사용하면 구현을 간접적으로 사용할 수 있기 때문에 나중에 구현을 바꾸기 쉽다.

2. 코드를 읽고 쓰기 쉽게 만들기 위해

때로는 구체적인 것이 버그를 만든다. 추상화 벽을 사용하면 이런 세부적인 것은 신경 쓰지 않고 쉽게 코드를 만들 수 있다.

3. 팀 간에 조율해야 할 것을 줄이기 위해

각 팀에 관한 구체적인 내용을 서로 신경 쓰지 않아도 일할 수 있다. 게다가 더 빨라진다.

4. 주어진 문제에 집중하기 위해

사람은 생각할 수 있는 두뇌에 한계가 있다. 고민해야 할 구체적인 문제가 많지만, 추상화 벽을 사용하면 해결하려는 문제의 구체적인 부분을 무시할 수 있다. 그래서, `실수를 줄이고 지치지 않을 수 있다!`

---

### 패턴 3: 작은 인터페이스

작은 인터페이스 패턴은 새로운 코드를 추가할 위치에 관한 내용이다. 인터페이스를 최소화하면 하위 계층에 불필요한 기능이 쓸데없이 커지는 것을 막을 수 있다!

> [!WARNING] 문제 상황
> : 마케팅팀은 장바구니에 제품을 많이 담은 사람이 시계를 구입하면 10%를 할인해 주려고 한다.

시계 할인 마케팅을 구현하기 위한 두 가지 방법은,

1. 추상화 벽에 구현하는 방법 : 해시 맵 데이터 구조로 되어 있는 장바구니 직접 접근 가능

```tsx
function getsWatchDiscount(cart) {
  let total = 0;
  const names = Object.keys(cart);
  for (let i = 0; i < names.length; i++) {
    const item = cart[names[i]];
    total += item.price;
  }
  return total > 100 && cart.hasOwnProperty("watch");
}
```

2. 추상화 벽 위에 있는 계층에 구현하는 방법 : 데이터 구조에 직접 접근 불가능하므로, 추상화 벽에 있는 함수 사용해서 장바구니 접근하기

```tsx
function getsWatchDiscount(cart) {
  const total = calcTotal(cart);
  const hasWatch = isInCart("watch");
  return total > 100 && hasWatch;
}
```

둘 중에, 2번째인 추상화 벽 위에 있는 계층에 구현하는 것이 더 좋다. 그 이유는,

- 추상화 벽 위에 있는 계층에 만드는 것이 더 직접 구현에 가깝다.
- 첫 번째 방법은 시스템 하위 계층 코드가 늘어나서 좋지 않다.
- 또한, 마케팅을 위한 코드인데 반복문 같은 구체적 구현에는 신경 쓰지 않고 싶으므로 반복문은 추상화 벽 아래에 들어가는 것이 더 적절하다.
- 추상화 벽에 구현하는 방법은 개발팀과 마케팅팀 사이에 계약이 늘어나게 되고 계약에 사용하는 용어를 맞추느라 시간이 많이 든다.

> [!NOTE]
> 새로운 기능을 만들 때 하위 계층에 기능을 추가하거나 고치는 것보다 상위 계층에 만드는 것이 작은 인터페이스 패턴이다.

#### 문제 : 마케팅팀의 장바구니에 제품 담을 때 로그 남기기

개발팀은 마케팅팀이 매출을 늘리기 위해 장바구니에 제품을 담을 때마다 로그를 남겨달라는 요청에 따라 메서드를 만들었다.

`logAddToCart(user_id, item)`가 어디에 위치해야 할 지를 정해야 한다.

제나는 add_item() 함수에서 호출할 것을 제안했다.

```tsx
function add_item(cart, item) {
  logAddToCart(global_user_id, item);
  return obejctSet(cart, item.name, item);
}
```

장바구니에 제품을 담을 때마다 로그를 남긴다는 관점에서도 문제가 없어 보이고 상위 계층은 이 함수가 로그를 남기고 있다는 사실을 몰라도 되므로 좋다.

**하지만, add_item은 logAddToCart라는 액션을 담게 되었으므로 같이 액션이 되고 테스트하기 어려워졌다.**

#### 장바구니 로그를 남길 더 좋은 위치

update_shippping_icons(cart)에서는 장바구니에 추가하지 않아도 로그가 찍힐 위험이 있으므로 제외하고, `add_item_to_cart()` 함수가 적절해 보인다.

```tsx
function add_item_to_cart(name, price) {
  const item = make_cart_item(name, price);
  shopping_cart = add_item(shopping_cart, item);
  const total = calc_total(shopping_cart);
  set_cart_total_dom(total);
  update_shipping_icons(shopping_cart);
  update_tax_dom(total);
  logAddToCart();
}
```

#### 패턴 3 리뷰: 작은 인터페이스

추상화 벽에 만든 함수가 바로 인터페이스다.

계층형 설계에서 완전한 추상화 벽과 최소한의 인터페이스 사이에 유연하게 조율해야 하는 점이 있다.

추상화 벽을 작게 만들어야 하는 이유는,

- 추상화 벽에 코드가 많을수록 구현이 변경되었을 때 고쳐야 할 것이 많다.
- 추상화 벽에 있는 코드는 낮은 수준의 코드이기 때문에 더 많은 버그가 있을 수 있다.
- 낮은 수준의 코드는 이해하기 더 어렵다.
- 추상화 벽에 코드가 많을수록 팀 간 조율해야 할 것도 많아진다.
- 추상화 벽에 인터페이스가 많으면 알아야 할 것이 많아 사용하기 어렵다.

상위 계층에 어떤 함수를 만들 때 가능한 현재 계층에 있는 함수로 구현하는 것이 작은 인터페이스를 실천하는 방법이다.

> [!NOTE]
> 수년간 소스 파일이 바뀌지 않고 많이 사용되는 코드는 상당히 이상적인데, 호출 그래프 하위 계층에 작고 강력한 동작을 만들었을 때 이런 모습을 볼 수 있다!

### 패턴 4: 편리한 계층

**언제 패턴을 적용하고 또 언제 멈춰야 하는지 실용적인 방법을 알려준다.** 쉽게 설명하자면, 지금 본인이 작업하는 코드가 편리하다고 느끼면 설계는 멈춰도 된다. 단, 구체적인 것을 너무 많이 알아야 하거나 코드가 지저분하다고 느끼면 다시 패턴을 적용해야 한다.

---

### 그래프로 알 수 있는 코드에 대한 정보는?

호출 그래프의 구조는 세 가지 중요한 비기능적 요구사항(소프트웨어가 정확히 해야 하는 일을 제외한 요구사항)을 꾸밈없이 보여준다.

1. 유지보수성
2. 테스트성
3. 재사용성

#### 그래프의 가장 위에 있는 코드가 고치기 가장 쉽다

가장 아래에 있는 코드를 기반으로 위의 코드를 작성했기 때문에,**아래에 있는 코드는 고치기 어렵고 반대로 위에 있는 코드는 고치기 쉽다!**

시간이 지나도 변하지 않는 코드는 가장 아래 계층에 있어야 한다. (ex. 카피-온-라이트 함수)

#### 아래에 있는 코드는 테스트가 중요하다.

모든 코드를 테스트하는 것은 현실적이지 않다. **많은 코드가 의존하고 있는 가장 아래에 있는 코드를 테스트하는 것이 중요하다!**

#### 아래에 있는 코드가 재사용하기 더 좋다.

호출 그래프에서 아래쪽으로 가리키는 화살표가 많은 함수는 재사용하기 어렵다. **가장 아래 있는 계층은 언어적 기능이나 계산 함수가 많아서 재사용하기 좋다!**
